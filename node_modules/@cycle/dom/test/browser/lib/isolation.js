"use strict";
var assert = require("assert");
var isolate_1 = require("@cycle/isolate");
var xstream_1 = require("xstream");
var delay_1 = require("xstream/extra/delay");
var concat_1 = require("xstream/extra/concat");
var run_1 = require("@cycle/run");
var lib_1 = require("../../../lib");
function createRenderTarget(id) {
    if (id === void 0) { id = null; }
    var element = document.createElement('div');
    element.className = 'cycletest';
    if (id) {
        element.id = id;
    }
    document.body.appendChild(element);
    return element;
}
describe('isolateSource', function () {
    it('should have the same effect as DOM.select()', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(lib_1.h3('.top-most', [
                    lib_1.h2('.bar', 'Wrong'),
                    lib_1.div({ isolate: 'foo' }, [
                        lib_1.h4('.bar', 'Correct'),
                    ]),
                ])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        // Make assertions
        isolatedDOMSource.select('.bar').elements().drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                setTimeout(function () {
                    dispose();
                    done();
                });
            },
        });
        dispose = run();
    });
    it('should return source also with isolateSource and isolateSink', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(lib_1.h('h3.top-most')),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose = run();
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'top-most');
        // Make assertions
        assert.strictEqual(typeof isolatedDOMSource.isolateSource, 'function');
        assert.strictEqual(typeof isolatedDOMSource.isolateSink, 'function');
        dispose();
        done();
    });
});
describe('isolateSink', function () {
    it('should add an isolate field to the vtree sink', function (done) {
        function app(sources) {
            var vtree$ = xstream_1.default.of(lib_1.h3('.top-most'));
            return {
                DOM: sources.DOM.isolateSink(vtree$, 'foo'),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        // Make assertions
        sinks.DOM.take(1).addListener({
            next: function (vtree) {
                assert.strictEqual(vtree.sel, 'h3.top-most');
                assert.strictEqual(vtree.data.isolate, 'foo');
                setTimeout(function () {
                    dispose();
                    done();
                });
            },
        });
        dispose = run();
    });
    it('should not redundantly repeat the scope className', function (done) {
        function app(sources) {
            var vtree1$ = xstream_1.default.of(lib_1.span('.tab1', 'Hi'));
            var vtree2$ = xstream_1.default.of(lib_1.span('.tab2', 'Hello'));
            var first$ = sources.DOM.isolateSink(vtree1$, '1');
            var second$ = sources.DOM.isolateSink(vtree2$, '2');
            var switched$ = concat_1.default(xstream_1.default.of(1).compose(delay_1.default(50)), xstream_1.default.of(2).compose(delay_1.default(50)), xstream_1.default.of(1).compose(delay_1.default(50)), xstream_1.default.of(2).compose(delay_1.default(50)), xstream_1.default.of(1).compose(delay_1.default(50)), xstream_1.default.of(2).compose(delay_1.default(50))).map(function (i) { return i === 1 ? first$ : second$; }).flatten();
            return {
                DOM: switched$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        // Make assertions
        sinks.DOM.drop(2).take(1).addListener({
            next: function (vtree) {
                assert.strictEqual(vtree.sel, 'span.tab1');
                assert.strictEqual(vtree.data.isolate, '1');
                dispose();
                done();
            },
        });
        dispose = run();
    });
});
describe('isolation', function () {
    it('should prevent parent from DOM.selecting() inside the isolation', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(lib_1.div('.foo', [
                lib_1.h4('.bar', 'Wrong'),
            ])), 'ISOLATION');
            var vdom$ = xstream_1.default.combine(xstream_1.default.of(null), child$).map(function (_a) {
                var _ = _a[0], child = _a[1];
                return lib_1.h3('.top-most', [
                    child,
                    lib_1.h2('.bar', 'Correct'),
                ]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM.select('.bar').elements().drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H2');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should allow parent to DOM.select() in its own isolation island', function (done) {
        function app(sources) {
            var _a = sources.DOM, isolateSource = _a.isolateSource, isolateSink = _a.isolateSink;
            var islandElement$ = isolateSource(sources.DOM, 'island')
                .select('.bar').elements();
            var islandVDom$ = sources.DOM.isolateSink(xstream_1.default.of(lib_1.div([lib_1.h3('.bar', 'Correct')])), 'island');
            var child$ = sources.DOM.isolateSink(islandVDom$.map(function (islandVDom) {
                return lib_1.div('.foo', [
                    islandVDom,
                    lib_1.h4('.bar', 'Wrong'),
                ]);
            }), 'ISOLATION');
            var vdom$ = child$.map(function (child) {
                return lib_1.h3('.top-most', [
                    child,
                ]);
            });
            return {
                DOM: vdom$,
                island: islandElement$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sinks.island.drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H3');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should isolate DOM.select between parent and (wrapper) child', function (done) {
        function Frame(sources) {
            var click$ = sources.DOM.select('.foo').events('click');
            var vdom$ = sources.content$.map(function (content) {
                return lib_1.h4('.foo.frame', { style: { backgroundColor: 'lightblue' } }, [
                    content,
                ]);
            });
            return {
                DOM: vdom$,
                click$: click$,
            };
        }
        function Monalisa(sources) {
            var _a = sources.DOM, isolateSource = _a.isolateSource, isolateSink = _a.isolateSink;
            var islandDOMSource = isolateSource(sources.DOM, 'island');
            var click$ = islandDOMSource.select('.foo').events('click');
            var islandDOMSink$ = isolateSink(xstream_1.default.of(lib_1.span('.foo.monalisa', 'Monalisa')), 'island');
            var frameDOMSource = isolateSource(sources.DOM, 'myFrame');
            var frame = Frame({ DOM: frameDOMSource, content$: islandDOMSink$ });
            var outerVTree$ = isolateSink(frame.DOM, 'myFrame');
            return {
                DOM: outerVTree$,
                frameClick: frame.click$,
                monalisaClick: click$,
            };
        }
        var _a = run_1.setup(Monalisa, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sources = _a.sources, sinks = _a.sinks, run = _a.run;
        var dispose;
        var frameClick$ = sinks.frameClick.map(function (ev) { return ({
            type: ev.type,
            tagName: ev.target.tagName,
        }); });
        var monalisaClick$ = sinks.monalisaClick.map(function (ev) { return ({
            type: ev.type,
            tagName: ev.target.tagName,
        }); });
        // Stop the propagtion of the first click
        sinks.monalisaClick.take(1).addListener({
            next: function (ev) { return ev.stopPropagation(); },
        });
        // The frame should be notified about 2 clicks:
        //  1. the second click on monalisa (whose propagation has not stopped)
        //  2. the only click on the frame itself
        var expected = [
            { type: 'click', tagName: 'SPAN' },
            { type: 'click', tagName: 'H4' },
        ];
        frameClick$.take(2).addListener({
            next: function (event) {
                var e = expected.shift();
                assert.strictEqual(event.type, e.type);
                assert.strictEqual(event.tagName, e.tagName);
                if (expected.length === 0) {
                    dispose();
                    done();
                }
            },
        });
        // Monalisa should receive two clicks
        var otherExpected = [
            { type: 'click', tagName: 'SPAN' },
            { type: 'click', tagName: 'SPAN' },
        ];
        monalisaClick$.take(2).addListener({
            next: function (event) {
                var e = otherExpected.shift();
                assert.strictEqual(event.type, e.type);
                assert.strictEqual(event.tagName, e.tagName);
            },
        });
        sources.DOM.select(':root').elements().drop(1).take(1).addListener({
            next: function (root) {
                var frameFoo = root.querySelector('.foo.frame');
                var monalisaFoo = root.querySelector('.foo.monalisa');
                assert.notStrictEqual(frameFoo, null);
                assert.notStrictEqual(monalisaFoo, null);
                assert.notStrictEqual(typeof frameFoo, 'undefined');
                assert.notStrictEqual(typeof monalisaFoo, 'undefined');
                assert.strictEqual(frameFoo.tagName, 'H4');
                assert.strictEqual(monalisaFoo.tagName, 'SPAN');
                assert.doesNotThrow(function () {
                    setTimeout(function () { return monalisaFoo.click(); });
                    setTimeout(function () { return monalisaFoo.click(); });
                    setTimeout(function () { return frameFoo.click(); }, 0);
                });
            },
        });
        dispose = run();
    });
    it('should allow a child component to DOM.select() its own root', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(lib_1.span('.foo', [
                lib_1.h4('.bar', 'Wrong'),
            ])), 'ISOLATION');
            return {
                DOM: child$.map(function (child) {
                    return lib_1.h3('.top-most', [
                        child,
                    ]);
                }),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolateSource = sources.DOM.isolateSource;
        var dispose;
        isolateSource(sources.DOM, 'ISOLATION')
            .select('.foo').elements()
            .drop(1).take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'SPAN');
                setTimeout(function () {
                    dispose();
                    done();
                });
            },
        });
        dispose = run();
    });
    it('should allow DOM.selecting svg elements', function (done) {
        function App(sources) {
            var triangleElement$ = sources.DOM.select('.triangle').elements();
            var svgTriangle = lib_1.svg({ width: 150, height: 150 }, [
                lib_1.svg.polygon({
                    attrs: {
                        class: 'triangle',
                        points: '20 0 20 150 150 20',
                    },
                }),
            ]);
            return {
                DOM: xstream_1.default.of(svgTriangle),
                triangleElement: triangleElement$,
            };
        }
        function IsolatedApp(sources) {
            var _a = sources.DOM, isolateSource = _a.isolateSource, isolateSink = _a.isolateSink;
            var isolatedDOMSource = isolateSource(sources.DOM, 'ISOLATION');
            var app = App({ DOM: isolatedDOMSource });
            var isolateDOMSink = isolateSink(app.DOM, 'ISOLATION');
            return {
                DOM: isolateDOMSink,
                triangleElement: app.triangleElement,
            };
        }
        var _a = run_1.setup(IsolatedApp, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        // Make assertions
        sinks.triangleElement.drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var triangleElement = elements[0];
                assert.notStrictEqual(triangleElement, null);
                assert.notStrictEqual(typeof triangleElement, 'undefined');
                assert.strictEqual(triangleElement.tagName, 'polygon');
                done();
            },
        });
        run();
    });
    it('should allow DOM.select()ing its own root without classname or id', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(lib_1.span([
                lib_1.h4('.bar', 'Wrong'),
            ])), 'ISOLATION');
            return {
                DOM: child$.map(function (child) {
                    return lib_1.h3('.top-most', [
                        child,
                    ]);
                }),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolateSource = sources.DOM.isolateSource;
        isolateSource(sources.DOM, 'ISOLATION')
            .select('span').elements()
            .drop(1).take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'SPAN');
                done();
            },
        });
        run();
    });
    it('should allow DOM.select()ing all elements with `*`', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(lib_1.span([
                lib_1.div([
                    lib_1.h4('.foo', 'hello'),
                    lib_1.h4('.bar', 'world'),
                ]),
            ])), 'ISOLATION');
            return {
                DOM: child$.map(function (child) {
                    return lib_1.h3('.top-most', [
                        child,
                    ]);
                }),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolateSource = sources.DOM.isolateSource;
        isolateSource(sources.DOM, 'ISOLATION')
            .select('*').elements()
            .drop(1).take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 4);
                done();
            },
        });
        run();
    });
    it('should select() isolated element with tag + class', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(lib_1.h3('.top-most', [
                    lib_1.h2('.bar', 'Wrong'),
                    lib_1.div({ isolate: 'foo' }, [
                        lib_1.h4('.bar', 'Correct'),
                    ]),
                ])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        // Make assertions
        isolatedDOMSource.select('h4.bar').elements().drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should process bubbling events from inner to outer component', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(lib_1.h3('.top-most', [
                    lib_1.h2('.bar', 'Wrong'),
                    lib_1.div({ isolate: 'foo' }, [
                        lib_1.h4('.bar', 'Correct'),
                    ]),
                ])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        var called = false;
        sources.DOM.select('.top-most').events('click').addListener({
            next: function (ev) {
                assert.strictEqual(called, true);
                dispose();
                done();
            },
        });
        isolatedDOMSource.select('h4.bar').events('click').addListener({
            next: function (ev) {
                assert.strictEqual(called, false);
                called = true;
            },
        });
        // Make assertions
        isolatedDOMSource.select('h4.bar').elements().drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                setTimeout(function () {
                    correctElement.click();
                });
            },
        });
        dispose = run();
    });
    it('should stop bubbling the event if the currentTarget was removed', function (done) {
        function main(sources) {
            var childExistence$ = sources.DOM.isolateSource(sources.DOM, 'foo')
                .select('h4.bar').events('click')
                .map(function () { return false; })
                .startWith(true);
            return {
                DOM: childExistence$.map(function (exists) {
                    return lib_1.div([
                        lib_1.div('.top-most', { isolate: 'top' }, [
                            lib_1.h2('.bar', 'Wrong'),
                            exists ? lib_1.div({ isolate: 'foo' }, [
                                lib_1.h4('.bar', 'Correct'),
                            ]) : null,
                        ]),
                    ]);
                }),
            };
        }
        var _a = run_1.setup(main, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var topDOMSource = sources.DOM.isolateSource(sources.DOM, 'top');
        var fooDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        var parentEventHandlerCalled = false;
        topDOMSource.select('.bar').events('click').addListener({
            next: function (ev) {
                parentEventHandlerCalled = true;
                done('this should not be called');
            },
        });
        // Make assertions
        fooDOMSource.select('.bar').elements().drop(1).take(1).addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                setTimeout(function () {
                    correctElement.click();
                    setTimeout(function () {
                        assert.strictEqual(parentEventHandlerCalled, false);
                        dispose();
                        done();
                    }, 150);
                });
            },
        });
        dispose = run();
    });
    it('should handle a higher-order graph when events() are subscribed', function (done) {
        var errorHappened = false;
        var clickDetected = false;
        function Child(sources) {
            return {
                DOM: sources.DOM.select('.foo').events('click')
                    .debug(function () { clickDetected = true; })
                    .replaceError(function () { errorHappened = true; return xstream_1.default.empty(); })
                    .mapTo(1)
                    .startWith(0)
                    .map(function (num) {
                    return lib_1.div('.container', [
                        lib_1.h3('.foo', 'Child foo'),
                    ]);
                }),
            };
        }
        function main(sources) {
            var first = isolate_1.default(Child, 'first')(sources);
            var second = isolate_1.default(Child, 'second')(sources);
            var oneChild = [first];
            var twoChildren = [first, second];
            var vnode$ = xstream_1.default.periodic(50).take(1).startWith(-1)
                .map(function (i) { return i === -1 ? oneChild : twoChildren; })
                .map(function (children) {
                return xstream_1.default.combine.apply(xstream_1.default, children.map(function (child) { return child.DOM; })).map(function (childVNodes) { return lib_1.div('.parent', childVNodes); });
            }).flatten();
            return {
                DOM: vnode$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM.select(':root').elements().drop(2).take(1).addListener({
            next: function (root) {
                var parentEl = root.querySelector('.parent');
                var foo = parentEl.querySelectorAll('.foo')[1];
                assert.notStrictEqual(parentEl, null);
                assert.notStrictEqual(typeof parentEl, 'undefined');
                assert.notStrictEqual(foo, null);
                assert.notStrictEqual(typeof foo, 'undefined');
                assert.strictEqual(parentEl.tagName, 'DIV');
                setTimeout(function () {
                    assert.strictEqual(errorHappened, false);
                    foo.click();
                    setTimeout(function () {
                        assert.strictEqual(clickDetected, true);
                        dispose();
                        done();
                    }, 50);
                }, 100);
            },
        });
        dispose = run();
    });
    it('should handle events when child is removed and re-added', function (done) {
        var clicksCount = 0;
        function Child(sources) {
            sources.DOM.select('.foo').events('click').addListener({
                next: function () { clicksCount++; },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.foo', ['This is foo'])),
            };
        }
        function main(sources) {
            var child = isolate_1.default(Child)(sources);
            // make child.DOM be inserted, removed, and inserted again
            var innerDOM$ = xstream_1.default.periodic(120).take(2).map(function (x) { return x + 1; }).startWith(0)
                .map(function (x) {
                return x === 1 ?
                    xstream_1.default.of(lib_1.div()) :
                    child.DOM;
            }).flatten();
            return {
                DOM: innerDOM$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM.select(':root').elements().drop(1).take(3).addListener({
            next: function (root) {
                setTimeout(function () {
                    var foo = root.querySelector('.foo');
                    if (!foo) {
                        return;
                    }
                    foo.click();
                }, 0);
            },
        });
        setTimeout(function () {
            assert.strictEqual(clicksCount, 2);
            dispose();
            done();
        }, 500);
        dispose = run();
    });
    it('should handle events when parent is removed and re-added', function (done) {
        var clicksCount = 0;
        function Child(sources) {
            sources.DOM.select('.foo').events('click').addListener({
                next: function () { clicksCount++; },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.foo', ['This is foo'])),
            };
        }
        function main(sources) {
            var child = isolate_1.default(Child, 'child')(sources);
            // change parent key, causing it to be recreated
            var x$ = xstream_1.default.periodic(120).map(function (x) { return x + 1; }).startWith(0).take(4);
            var innerDOM$ = xstream_1.default.combine(x$, child.DOM)
                .map(function (_a) {
                var x = _a[0], childVDOM = _a[1];
                return lib_1.div(".parent" + x, { key: "key" + x }, [childVDOM, "" + x]);
            });
            return {
                DOM: innerDOM$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM.select(':root').elements().drop(1).take(4).addListener({
            next: function (root) {
                setTimeout(function () {
                    var foo = root.querySelector('.foo');
                    if (!foo) {
                        return;
                    }
                    foo.click();
                }, 0);
            },
        });
        setTimeout(function () {
            assert.strictEqual(clicksCount, 4);
            dispose();
            done();
        }, 800);
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM.select('.btn').events('click').addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.component', {}, [
                    lib_1.button('.btn', {}, 'Hello'),
                ])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component)(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main)(sources);
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM.elements().drop(1).take(1).addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component when scope is explicitly ' +
        'specified on child', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM.select('.btn').events('click').addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.component', {}, [
                    lib_1.button('.btn', {}, 'Hello'),
                ])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component, 'foo')(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main)(sources);
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM.elements().drop(1).take(1).addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component when scope is explicitly ' +
        'specified on parent', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM.select('.btn').events('click').addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.component', {}, [
                    lib_1.button('.btn', {}, 'Hello'),
                ])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component)(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main, 'foo')(sources);
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM.elements().drop(1).take(1).addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component when scope is explicitly ' +
        'specified on parent and child', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM.select('.btn').events('click').addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.component', {}, [
                    lib_1.button('.btn', {}, 'Hello'),
                ])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component, 'bar')(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main, 'foo')(sources);
        }
        var _a = run_1.setup(app, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM.elements().drop(1).take(1).addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should maintain virtual DOM list sanity using keys, in a list of ' +
        'isolated components', function (done) {
        var componentRemove$ = xstream_1.default.create();
        function Component(sources) {
            sources.DOM.select('.btn').events('click').addListener({
                next: function (ev) {
                    componentRemove$.shamefullySendNext(null);
                },
            });
            return {
                DOM: xstream_1.default.of(lib_1.div('.component', {}, [
                    lib_1.button('.btn', {}, 'Hello'),
                ])),
            };
        }
        function main(sources) {
            var remove$ = componentRemove$.compose(delay_1.default(50)).fold(function (acc) { return acc + 1; }, 0);
            var first = isolate_1.default(Component, 'first')(sources);
            var second = isolate_1.default(Component, 'second')(sources);
            var vdom$ = xstream_1.default.combine(first.DOM, second.DOM, remove$)
                .map(function (_a) {
                var vdom1 = _a[0], vdom2 = _a[1], r = _a[2];
                if (r === 0) {
                    return lib_1.div([vdom1, vdom2]);
                }
                else if (r === 1) {
                    return lib_1.div([vdom2]);
                }
                else if (r === 2) {
                    return lib_1.div([]);
                }
                else {
                    done('This case must not happen.');
                }
            });
            return { DOM: vdom$ };
        }
        var _a = run_1.setup(main, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM.elements().drop(1).take(1).addListener({
            next: function (root) {
                var components = root.querySelectorAll('.btn');
                assert.strictEqual(components.length, 2);
                var firstElement = components[0];
                var secondElement = components[1];
                setTimeout(function () {
                    firstElement.click();
                }, 100);
                setTimeout(function () {
                    secondElement.click();
                }, 300);
                setTimeout(function () {
                    assert.strictEqual(root.querySelectorAll('.component').length, 0);
                    dispose();
                    done();
                }, 500);
            },
        });
        dispose = run();
    });
    it('should allow recursive isolation using the same scope', function (done) {
        function Item(sources, count) {
            var childVdom$ = count > 0 ?
                isolate_1.default(Item, '0')(sources, count - 1).DOM :
                xstream_1.default.of(null);
            var highlight$ = sources.DOM.select('button').events('click').mapTo(true)
                .fold(function (x, _) { return !x; }, false);
            var vdom$ = xstream_1.default.combine(childVdom$, highlight$)
                .map(function (_a) {
                var childVdom = _a[0], highlight = _a[1];
                return lib_1.div([
                    lib_1.button('.btn', highlight ? 'HIGHLIGHTED' : 'click me'),
                    childVdom,
                ]);
            });
            return { DOM: vdom$ };
        }
        function main(sources) {
            var vdom$ = Item(sources, 3).DOM;
            return { DOM: vdom$ };
        }
        var _a = run_1.setup(main, {
            DOM: lib_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM.elements().drop(1).take(1).addListener({
            next: function (root) {
                var buttons = root.querySelectorAll('.btn');
                assert.strictEqual(buttons.length, 4);
                var firstButton = buttons[0];
                var secondButton = buttons[1];
                var thirdButton = buttons[2];
                var forthButton = buttons[3];
                setTimeout(function () {
                    thirdButton.click();
                }, 100);
                setTimeout(function () {
                    assert.notStrictEqual(firstButton.textContent, 'HIGHLIGHTED');
                    assert.notStrictEqual(secondButton.textContent, 'HIGHLIGHTED');
                    assert.strictEqual(thirdButton.textContent, 'HIGHLIGHTED');
                    assert.notStrictEqual(forthButton.textContent, 'HIGHLIGHTED');
                    dispose();
                    done();
                }, 300);
            },
        });
        dispose = run();
    });
});
